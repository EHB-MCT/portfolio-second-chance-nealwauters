
    const animate = (timestamp) => {
      // Define the target position for the dart's tip
       targetDartPosition = randomPosition;   
       throwDuration = 1500;
  console.log('animation running');
  if (!isAnimating) return;
  const deltaTime = timestamp - elapsedTime;
  elapsedTime = timestamp;
  
  // Calculate the progress of the throwing motion
  const progress = THREE.MathUtils.clamp(elapsedTime / throwDuration, 0, 1);
  
  // Calculate the throwing arc based on a sine function
  const throwingArcProgress = Math.sin(progress * Math.PI);
  const throwingArcHeight = 80; // Adjust the throwing arc height
  
  // Calculate the intermediate position with the throwing arc
  const throwPosition = new THREE.Vector3().copy(initialPosition).lerp(targetDartPosition, progress);
  throwPosition.y += throwingArcHeight * throwingArcProgress; // Add the throwing arc height
  
  // Calculate the rotation for this frame (maintain consistent rotation)
  const throwRotation = targetDartRotation.clone();
  
  // Apply the calculated position to the dart
  dart.position.copy(throwPosition);
  
  // Rotate the dart around itself
  dart.rotation.z += 0.1; // Adjust the rotation speed as needed
  
  if (progress === 1) {
    // Calculate the distance between the dart's position and the origin
    const dartPosition = dart.position.clone();
    const distanceToOrigin = calculateDistanceToOrigin(dartPosition);
  
    // Define the multiplication factors and distance ranges
    const factorInRange1 = 3; // Multiply if distance is between range1
    const factorInRange2 = 2; // Multiply if distance is between range2
    const range1Min = 117;
    const range1Max = 122;
    const range2Min = 152;
    const range2Max = 156;
  
    let finalValue = randomSectionValue; // Default value
  
    if (distanceToOrigin >= range1Min && distanceToOrigin <= range1Max) {
      finalValue *= factorInRange1;
    } else if (distanceToOrigin >= range2Min && distanceToOrigin <= range2Max) {
      finalValue *= factorInRange2;
    }
  
    console.log(`Distance to origin: ${distanceToOrigin}`);
    console.log(`Final value after distance adjustment: ${finalValue}`);
  
  
    console.log(`Dart landed at section ${closestSectionKey} with value ${landedSection.value}, multiplied value: ${multipliedValue}`);
    isAnimating = false;
  
  }
  
  // Apply the calculated rotation to the dart
  dart.rotation.copy(throwRotation);
  
  renderer.render(scene, camera);
  if (isAnimating) {
    requestAnimationFrame(animate);
  }
  };
    
   targetDart = dart.clone();
    // Choose a random section key from the vertices object
    const randomSectionKey = Object.keys(vertices)[Math.floor(Math.random() * Object.keys(vertices).length)];
    const randomSection = vertices[randomSectionKey];
    const randomSectionValue = randomSection.value; // Accessing the value property of the chosen section

    // Generate a random position within the chosen section
    randomPosition = generateRandomPositionInSection(randomSection.vertices);
    console.log(randomPosition); // This is a Vector3 object
    console.log(randomSectionValue); // This will print the value of the chosen section